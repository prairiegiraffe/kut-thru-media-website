---
// Text scramble effect - characters scramble then reveal the word
interface Props {
  text: string;
  element?: 'h1' | 'h2' | 'h3' | 'p' | 'span';
  class?: string;
  duration?: number;
  trigger?: 'load' | 'scroll' | 'hover';
}

const {
  text,
  element: Element = 'span',
  class: className = '',
  duration = 1.5,
  trigger = 'scroll',
} = Astro.props;
---

<Element
  class:list={['text-scramble', className]}
  data-text={text}
  data-duration={duration}
  data-trigger={trigger}
>
  {text}
</Element>

<style>
  .text-scramble {
    display: inline-block;
  }
</style>

<script>
  import gsap from 'gsap';
  import { ScrollTrigger } from 'gsap/ScrollTrigger';

  gsap.registerPlugin(ScrollTrigger);

  class TextScrambler {
    el: HTMLElement;
    chars: string = '!<>-_\\/[]{}â€”=+*^?#________';
    originalText: string;
    duration: number;
    queue: Array<{ from: string; to: string; start: number; end: number; char?: string }> = [];
    frameRequest: number = 0;
    frame: number = 0;
    resolve!: () => void;

    constructor(el: HTMLElement) {
      this.el = el;
      this.originalText = el.getAttribute('data-text') || el.innerText;
      this.duration = parseFloat(el.getAttribute('data-duration') || '1.5') * 60; // Convert to frames
    }

    setText(newText: string): Promise<void> {
      const oldText = this.el.innerText;
      const length = Math.max(oldText.length, newText.length);
      const promise = new Promise<void>((resolve) => (this.resolve = resolve));
      this.queue = [];

      for (let i = 0; i < length; i++) {
        const from = oldText[i] || '';
        const to = newText[i] || '';
        const start = Math.floor(Math.random() * 40);
        const end = start + Math.floor(Math.random() * 40);
        this.queue.push({ from, to, start, end });
      }

      cancelAnimationFrame(this.frameRequest);
      this.frame = 0;
      this.update();
      return promise;
    }

    update() {
      let output = '';
      let complete = 0;

      for (let i = 0; i < this.queue.length; i++) {
        let { from, to, start, end, char } = this.queue[i];

        if (this.frame >= end) {
          complete++;
          output += to;
        } else if (this.frame >= start) {
          if (!char || Math.random() < 0.28) {
            char = this.randomChar();
            this.queue[i].char = char;
          }
          output += `<span class="text-power-red">${char}</span>`;
        } else {
          output += from;
        }
      }

      this.el.innerHTML = output;

      if (complete === this.queue.length) {
        this.resolve();
      } else {
        this.frameRequest = requestAnimationFrame(() => this.update());
        this.frame++;
      }
    }

    randomChar(): string {
      return this.chars[Math.floor(Math.random() * this.chars.length)];
    }
  }

  // Initialize all scramble elements
  document.querySelectorAll('.text-scramble').forEach((el) => {
    const htmlEl = el as HTMLElement;
    const scrambler = new TextScrambler(htmlEl);
    const trigger = htmlEl.getAttribute('data-trigger');
    const originalText = htmlEl.getAttribute('data-text') || htmlEl.innerText;

    if (trigger === 'load') {
      // Scramble on page load
      htmlEl.innerText = '';
      setTimeout(() => scrambler.setText(originalText), 500);
    } else if (trigger === 'scroll') {
      // Scramble on scroll into view
      ScrollTrigger.create({
        trigger: htmlEl,
        start: 'top 80%',
        onEnter: () => scrambler.setText(originalText),
        once: true,
      });
    } else if (trigger === 'hover') {
      // Scramble on hover
      htmlEl.addEventListener('mouseenter', () => {
        scrambler.setText(originalText);
      });
    }
  });
</script>
