---
import '../styles/global.css';
import CustomCursor from '../components/effects/CustomCursor.astro';
import SmoothScroll from '../components/effects/SmoothScroll.astro';
import PageTransition from '../components/effects/PageTransition.astro';
import GrainOverlay from '../components/effects/GrainOverlay.astro';
import ScrollProgress from '../components/effects/ScrollProgress.astro';

interface Props {
  title: string;
  description?: string;
}

const {
  title,
  description = "Marketing agency for Oil & Gas, Construction, Mining, and Heavy Industrial companies. Branding, websites, photography, video, and social media that actually works."
} = Astro.props;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content={description} />
    <meta name="generator" content={Astro.generator} />

    <!-- Open Graph -->
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="KUT | THRŪ Media" />

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content={title} />
    <meta name="twitter:description" content={description} />

    <link rel="icon" type="image/png" href="/Icon White.png" />
    <title>{title}</title>
  </head>
  <body class="min-h-screen flex flex-col">
    <!-- Loading Screen -->
    <div id="loading-screen" class="loading-screen">
      <div class="loading-logo">
        <img
          src="/assets/images/Logos/Full Logo White.png"
          alt="KUT | THRŪ Media"
          class="h-12 md:h-16 w-auto"
        />
      </div>
    </div>

    <!-- Global Effects -->
    <CustomCursor />
    <SmoothScroll />
    <PageTransition />
    <GrainOverlay opacity={0.03} />
    <ScrollProgress />

    <!-- Main Content -->
    <slot />

    <!-- Editor Bridge Script (dev only, inside iframe) -->
    <script is:inline>
    (function() {
      // Only activate when loaded inside the editor iframe
      const params = new URLSearchParams(window.location.search);
      if (window.parent === window || !params.has('_editor')) return;

      let editActive = false;
      let activeEl = null;

      // Inject editor styles
      const style = document.createElement('style');
      style.textContent = `
        .ck-editable { position: relative; cursor: pointer; outline: 2px dashed transparent; outline-offset: 3px; transition: outline .12s, box-shadow .12s; }
        .ck-editable:hover { outline: 2px dashed rgba(59,130,246,0.5); }
        .ck-editable.ck-active { outline: 2px solid #3b82f6 !important; box-shadow: 0 0 0 4px rgba(59,130,246,0.12); outline-offset: 3px; }
        .ck-editable:hover::before { content: attr(data-content-key); position: absolute; top: -22px; left: 0; z-index: 9999; background: #3b82f6; color: #fff; font-size: 9px; font-weight: 700; padding: 2px 6px; border-radius: 3px; font-family: monospace; letter-spacing: .5px; white-space: nowrap; pointer-events: none; }
        body.ck-edit-mode { cursor: default !important; }
        body.ck-edit-mode * { cursor: inherit !important; }
      `;
      document.head.appendChild(style);

      // Skip loading screen when in editor
      window.addEventListener('DOMContentLoaded', () => {
        const ls = document.getElementById('loading-screen');
        if (ls) { ls.style.display = 'none'; }
      });

      // Listen for messages from editor shell
      window.addEventListener('message', (e) => {
        const msg = e.data;
        if (!msg || !msg.type) return;

        if (msg.type === 'enter-edit-mode') {
          editActive = true;
          document.body.classList.add('ck-edit-mode');
          activateEditables();
        }

        if (msg.type === 'exit-edit-mode') {
          editActive = false;
          document.body.classList.remove('ck-edit-mode');
          deactivateEditables();
        }

        if (msg.type === 'update-content') {
          updateElement(msg.key, msg.value, msg.contentType);
        }
      });

      function activateEditables() {
        document.querySelectorAll('[data-content-key]').forEach(el => {
          el.classList.add('ck-editable');
        });
      }

      function deactivateEditables() {
        document.querySelectorAll('.ck-editable').forEach(el => {
          el.classList.remove('ck-editable', 'ck-active');
          el.contentEditable = 'false';
        });
        activeEl = null;
      }

      // Click handler for editable elements
      document.addEventListener('click', (e) => {
        if (!editActive) return;

        const el = e.target.closest('[data-content-key]');

        // Deselect previous
        if (activeEl && activeEl !== el) {
          activeEl.classList.remove('ck-active');
          if (!activeEl.dataset.contentType || activeEl.dataset.contentType === 'text') {
            activeEl.contentEditable = 'false';
          }
        }

        if (!el) {
          activeEl = null;
          return;
        }

        e.preventDefault();
        e.stopPropagation();
        activeEl = el;
        el.classList.add('ck-active');

        const key = el.dataset.contentKey;
        const type = el.dataset.contentType || 'text';

        // Get current value based on type
        let currentValue = '';
        if (type === 'bg-image') {
          const bg = el.style.backgroundImage;
          currentValue = bg ? bg.replace(/^url\(['"]?/, '').replace(/['"]?\)$/, '') : '';
        } else if (type === 'image') {
          const img = el.tagName === 'IMG' ? el : el.querySelector('img');
          currentValue = img ? img.src : '';
        } else {
          currentValue = el.textContent.trim();
          el.contentEditable = 'true';
          el.focus();
        }

        // Tell editor shell about the click
        window.parent.postMessage({
          type: 'element-clicked',
          key: key,
          contentType: type,
          currentValue: currentValue
        }, '*');
      }, true);

      // Text change handler
      document.addEventListener('input', (e) => {
        if (!editActive) return;
        const el = e.target.closest('[data-content-key]');
        if (!el) return;
        const type = el.dataset.contentType || 'text';
        if (type !== 'text') return;
        window.parent.postMessage({
          type: 'text-changed',
          key: el.dataset.contentKey,
          newValue: el.textContent.trim()
        }, '*');
      });

      // Update an element with new content
      function updateElement(key, value, contentType) {
        const el = document.querySelector('[data-content-key="' + key + '"]');
        if (!el) return;

        if (contentType === 'bg-image' || contentType === 'bg-image') {
          el.style.backgroundImage = "url('" + value + "')";
        } else if (contentType === 'image') {
          const img = el.tagName === 'IMG' ? el : el.querySelector('img');
          if (img) {
            img.src = value;
          } else {
            // Replace placeholder content with an image
            el.innerHTML = '<img src="' + value + '" alt="" style="width:100%;height:100%;object-fit:cover" />';
          }
        } else {
          el.textContent = value;
        }
      }

      // Report ready when page loads
      window.addEventListener('load', () => {
        const keys = Array.from(document.querySelectorAll('[data-content-key]')).map(el => el.dataset.contentKey);
        window.parent.postMessage({ type: 'page-ready', contentKeys: keys }, '*');
      });
    })();
    </script>

    <!-- Initialize Animations -->
    <script>
      import gsap from 'gsap';
      import { ScrollTrigger } from 'gsap/ScrollTrigger';

      gsap.registerPlugin(ScrollTrigger);

      const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

      // Mark elements for animation (they start visible, this hides them)
      const animatedElements = document.querySelectorAll('[data-animate]');

      // Hide loading screen
      window.addEventListener('load', () => {
        const loadingScreen = document.getElementById('loading-screen');

        gsap.to(loadingScreen, {
          opacity: 0,
          duration: 0.6,
          delay: 0.3,
          ease: 'power2.out',
          onComplete: () => {
            loadingScreen?.classList.add('hidden');
          }
        });

        if (isTouchDevice) {
          // On mobile: just show elements immediately, no scroll-triggered animations
          animatedElements.forEach((el) => el.classList.add('animated'));
        } else {
          // On desktop: use ScrollTrigger for scroll-based animations
          animatedElements.forEach((el) => el.classList.add('will-animate'));

          setTimeout(() => {
            animatedElements.forEach((el) => {
              ScrollTrigger.create({
                trigger: el,
                start: 'top 90%',
                onEnter: () => el.classList.add('animated'),
                once: true,
              });
            });
            ScrollTrigger.refresh();
          }, 100);
        }
      });

      // Refresh ScrollTrigger on resize (desktop only)
      if (!isTouchDevice) {
        let resizeTimer: ReturnType<typeof setTimeout>;
        window.addEventListener('resize', () => {
          clearTimeout(resizeTimer);
          resizeTimer = setTimeout(() => {
            ScrollTrigger.refresh();
          }, 250);
        });
      }
    </script>
  </body>
</html>
